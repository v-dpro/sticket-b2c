generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ==================== USERS ====================

model User {
  id                 String         @id @default(cuid())
  email              String         @unique
  passwordHash       String?
  username           String         @unique
  displayName        String?
  bio                String?
  avatarUrl          String?
  city               String?
  spotifyId          String?        @unique
  spotifyUsername    String?
  spotifyToken       String?
  spotifyRefresh     String?
  spotifyTokenExpiry DateTime?
  appleMusicId       String?
  privacySetting     PrivacySetting @default(PUBLIC)
  createdAt          DateTime       @default(now())
  updatedAt          DateTime       @updatedAt

  logs                    UserLog[]
  tickets                 UserTicket[]
  photos                  LogPhoto[]
  following               Follow[]                 @relation("UserFollowing")
  followers               Follow[]                 @relation("UserFollowers")
  artistFollows           UserArtistFollow[]
  interestedEvents        UserInterested[]
  badges                  UserBadge[]
  venueRatings            VenueRating[]
  venueTips               VenueTip[]
  seatViews               SeatView[]
  comments                Comment[]
  notifications           Notification[]           @relation("UserNotifications")
  notificationsSent       Notification[]           @relation("NotificationActor")
  notificationPreferences NotificationPreferences?
  pushTokens              PushToken[]

  @@index([email])
  @@index([username])
  @@index([spotifyId])
  @@index([city])
}

enum PrivacySetting {
  PUBLIC
  FRIENDS
  PRIVATE
}

// ==================== FOLLOWS ====================

model Follow {
  id          String   @id @default(cuid())
  followerId  String
  followingId String
  createdAt   DateTime @default(now())

  follower  User @relation("UserFollowing", fields: [followerId], references: [id], onDelete: Cascade)
  following User @relation("UserFollowers", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
}

// ==================== ARTISTS ====================

model Artist {
  id            String   @id @default(cuid())
  name          String
  spotifyId     String?  @unique
  bandsintownId String?  @unique
  imageUrl      String?
  genres        String[] @default([])
  bio           String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  events    Event[]
  followers UserArtistFollow[]

  @@index([name])
  @@index([spotifyId])
}

model UserArtistFollow {
  id        String   @id @default(cuid())
  notify    Boolean  @default(true)
  createdAt DateTime @default(now())

  userId   String
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  artistId String
  artist   Artist @relation(fields: [artistId], references: [id], onDelete: Cascade)

  @@unique([userId, artistId])
  @@index([userId])
  @@index([artistId])
}

// ==================== VENUES ====================

model Venue {
  id        String   @id @default(cuid())
  name      String
  city      String
  state     String?
  country   String   @default("US")
  address   String?
  lat       Float?
  lng       Float?
  capacity  Int?
  imageUrl  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  events    Event[]
  ratings   VenueRating[]
  tips      VenueTip[]
  seatViews SeatView[]

  @@unique([name, city, country])
  @@index([city])
  @@index([name])
}

model VenueRating {
  id         String   @id @default(cuid())
  sound      Int?
  sightlines Int?
  drinks     Int?
  staff      Int?
  access     Int?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  userId  String
  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  venueId String
  venue   Venue  @relation(fields: [venueId], references: [id], onDelete: Cascade)

  @@unique([userId, venueId])
}

model VenueTip {
  id        String   @id @default(cuid())
  text      String
  upvotes   Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId  String
  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  venueId String
  venue   Venue  @relation(fields: [venueId], references: [id], onDelete: Cascade)

  @@index([venueId])
}

model SeatView {
  id        String   @id @default(cuid())
  section   String
  row       String?
  photoUrl  String
  createdAt DateTime @default(now())

  userId  String
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  venueId String
  venue   Venue   @relation(fields: [venueId], references: [id], onDelete: Cascade)
  eventId String?
  event   Event?  @relation(fields: [eventId], references: [id])

  @@index([venueId, section])
}

// ==================== EVENTS ====================

model Event {
  id          String    @id @default(cuid())
  name        String
  date        DateTime
  endDate     DateTime?
  imageUrl    String?
  ticketUrl   String?
  source      String?
  externalId  String?
  setlistfmId String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  artistId String
  artist   Artist @relation(fields: [artistId], references: [id])
  venueId  String
  venue    Venue  @relation(fields: [venueId], references: [id])

  logs       UserLog[]
  tickets    UserTicket[]
  interested UserInterested[]
  seatViews  SeatView[]
  setlist    SetlistSong[]

  @@unique([artistId, venueId, date])
  @@index([date])
  @@index([artistId])
  @@index([venueId])
}

model SetlistSong {
  id       String  @id @default(cuid())
  position Int
  songName String
  isEncore Boolean @default(false)
  info     String?

  eventId String
  event   Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@index([eventId])
}

model UserInterested {
  id           String   @id @default(cuid())
  notifyOnSale Boolean  @default(true)
  createdAt    DateTime @default(now())

  userId  String
  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  eventId String
  event   Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([userId, eventId])
  @@index([userId])
  @@index([eventId])
}

// ==================== LOGS ====================

model UserLog {
  id         String         @id @default(cuid())
  section    String?
  row        String?
  seat       String?
  rating     Float?
  note       String?
  visibility PrivacySetting @default(PUBLIC)
  createdAt  DateTime       @default(now())
  updatedAt  DateTime       @updatedAt

  userId  String
  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  eventId String
  event   Event  @relation(fields: [eventId], references: [id])

  photos      LogPhoto[]
  comments    Comment[]
  taggedUsers LogTag[]

  @@unique([userId, eventId])
  @@index([userId])
  @@index([eventId])
  @@index([createdAt])
}

model LogPhoto {
  id           String         @id @default(cuid())
  photoUrl     String
  thumbnailUrl String?
  visibility   PrivacySetting @default(PUBLIC)
  isFlagged    Boolean        @default(false)
  width        Int?
  height       Int?
  createdAt    DateTime       @default(now())

  logId  String
  log    UserLog @relation(fields: [logId], references: [id], onDelete: Cascade)
  userId String
  user   User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([logId])
}

model LogTag {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  logId        String
  log          UserLog @relation(fields: [logId], references: [id], onDelete: Cascade)
  taggedUserId String

  @@unique([logId, taggedUserId])
}

model Comment {
  id        String   @id @default(cuid())
  text      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId String
  user   User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  logId  String
  log    UserLog @relation(fields: [logId], references: [id], onDelete: Cascade)

  @@index([logId])
}

// ==================== TICKETS ====================

model UserTicket {
  id      String @id @default(cuid())
  userId  String
  eventId String

  section            String?
  row                String?
  seat               String?
  isGeneralAdmission Boolean @default(false)

  barcode         String?
  // New canonical field for the wallet UI. Keep barcodeType for legacy rows.
  barcodeFormat   String  @default("UNKNOWN")
  barcodeType     String?
  barcodeImageUrl String?

  status TicketStatus @default(KEEPING)
  source TicketSource @default(MANUAL)

  // Phase 2 prep
  askingPrice Float?

  purchasePrice      Float?
  purchaseDate       DateTime?
  confirmationNumber String?
  notes              String?

  sourceEmail String?
  rawEmailId  String?
  pdfUrl      String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  event Event @relation(fields: [eventId], references: [id])

  @@unique([userId, eventId, barcode])
  @@index([userId])
  @@index([eventId])
  @@index([status])
}

enum TicketStatus {
  KEEPING
  SELLING
  SOLD
  TRANSFERRED
}

enum TicketSource {
  EMAIL
  MANUAL
  SCAN
  TRANSFER
}

// ==================== BADGES ====================

model Badge {
  id          String   @id @default(cuid())
  name        String   @unique
  description String
  iconUrl     String?
  criteria    Json
  tier        Int      @default(1)
  createdAt   DateTime @default(now())

  users UserBadge[]
}

model UserBadge {
  id       String   @id @default(cuid())
  earnedAt DateTime @default(now())

  userId  String
  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  badgeId String
  badge   Badge  @relation(fields: [badgeId], references: [id], onDelete: Cascade)

  @@unique([userId, badgeId])
}

// ==================== NOTIFICATIONS ====================

model Notification {
  id        String   @id @default(cuid())
  userId    String
  actorId   String?
  type      String
  title     String
  body      String
  data      Json
  read      Boolean  @default(false)
  createdAt DateTime @default(now())

  user  User  @relation("UserNotifications", fields: [userId], references: [id], onDelete: Cascade)
  actor User? @relation("NotificationActor", fields: [actorId], references: [id], onDelete: SetNull)

  @@index([userId, createdAt])
  @@index([userId, read])
}

model NotificationPreferences {
  id     String @id @default(cuid())
  userId String @unique

  // Social
  follows      Boolean @default(true)
  comments     Boolean @default(true)
  tags         Boolean @default(true)
  wasThere     Boolean @default(true)
  friendLogged Boolean @default(true)

  // Shows
  artistAnnouncements Boolean @default(true)
  ticketsOnSale       Boolean @default(true)
  showReminders       Boolean @default(true)
  postShowPrompts     Boolean @default(true)

  // Delivery
  pushEnabled Boolean @default(true)
  emailDigest String  @default("none") // none, daily, weekly

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model PushToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}
