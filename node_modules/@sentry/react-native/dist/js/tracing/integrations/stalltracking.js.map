{"version":3,"file":"stalltracking.js","sourceRoot":"","sources":["../../../../src/js/tracing/integrations/stalltracking.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable max-lines */\nimport type { Client, Integration, Measurements, MeasurementUnit, Span } from '@sentry/core';\nimport { debug, getRootSpan, spanToJSON, timestampInSeconds } from '@sentry/core';\nimport type { AppStateStatus } from 'react-native';\nimport { AppState } from 'react-native';\nimport { STALL_COUNT, STALL_LONGEST_TIME, STALL_TOTAL_TIME } from '../../measurements';\nimport { isRootSpan } from '../../utils/span';\nimport { getLatestChildSpanEndTimestamp, isNearToNow, setSpanMeasurement } from '../utils';\n\nconst INTEGRATION_NAME = 'StallTracking';\n\nexport interface StallMeasurements extends Measurements {\n  [STALL_COUNT]: { value: number; unit: MeasurementUnit };\n  [STALL_TOTAL_TIME]: { value: number; unit: MeasurementUnit };\n  [STALL_LONGEST_TIME]: { value: number; unit: MeasurementUnit };\n}\n\n/** Margin of error of 20ms */\nconst MARGIN_OF_ERROR_SECONDS = 0.02;\n/** How long between each iteration in the event loop tracker timeout */\nconst LOOP_TIMEOUT_INTERVAL_MS = 50;\n/** Limit for how many transactions the stall tracker will track at a time to prevent leaks due to transactions not being finished */\nconst MAX_RUNNING_TRANSACTIONS = 10;\n\n/**\n * Stall measurement tracker inspired by the `JSEventLoopWatchdog` used internally in React Native:\n * https://github.com/facebook/react-native/blob/006f5afe120c290a37cf6ff896748fbc062bf7ed/Libraries/Interaction/JSEventLoopWatchdog.js\n *\n * However, we modified the interval implementation to instead have a fixed loop timeout interval of `LOOP_TIMEOUT_INTERVAL_MS`.\n * We then would consider that iteration a stall when the total time for that interval to run is greater than `LOOP_TIMEOUT_INTERVAL_MS + minimumStallThreshold`\n */\nexport const stallTrackingIntegration = ({\n  minimumStallThresholdMs = 50,\n}: {\n  /**\n   * How long in milliseconds an event loop iteration can be delayed for before being considered a \"stall.\"\n   * @default 50\n   */\n  minimumStallThresholdMs?: number;\n} = {}): Integration => {\n  const statsByRootSpan: Map<\n    Span,\n    {\n      longestStallTime: number;\n      atStart: StallMeasurements;\n      atTimestamp: {\n        timestamp: number;\n        stats: StallMeasurements;\n      } | null;\n    }\n  > = new Map();\n\n  const state: {\n    isTracking: boolean;\n    timeout: ReturnType<typeof setTimeout> | null;\n    isBackground: boolean;\n    /** Switch that enables the iteration once app moves from background to foreground. */\n    backgroundEventListener: (appState: AppStateStatus) => void;\n    /** The last timestamp the iteration ran in milliseconds */\n    lastIntervalMs: number;\n    /** Total amount of time of all stalls that occurred during the current tracking session */\n    totalStallTime: number;\n    /** Total number of stalls that occurred during the current tracking session */\n    stallCount: number;\n    /**\n     * Iteration of the stall tracking interval. Measures how long the timer strayed from its expected time of running, and how\n     * long the stall is for.\n     */\n    iteration: () => void;\n  } = {\n    isTracking: false,\n    timeout: null,\n    isBackground: false,\n    lastIntervalMs: 0,\n    totalStallTime: 0,\n    stallCount: 0,\n    backgroundEventListener: (appState: AppStateStatus): void => {\n      if (appState === ('active' as AppStateStatus)) {\n        state.isBackground = false;\n        if (state.timeout != null) {\n          state.lastIntervalMs = timestampInSeconds() * 1000;\n          state.iteration();\n        }\n      } else {\n        state.isBackground = true;\n        state.timeout !== null && clearTimeout(state.timeout);\n      }\n    },\n    iteration: (): void => {\n      const now = timestampInSeconds() * 1000;\n      const totalTimeTaken = now - state.lastIntervalMs;\n\n      if (totalTimeTaken >= LOOP_TIMEOUT_INTERVAL_MS + minimumStallThresholdMs) {\n        const stallTime = totalTimeTaken - LOOP_TIMEOUT_INTERVAL_MS;\n        state.stallCount += 1;\n        state.totalStallTime += stallTime;\n\n        for (const [transaction, value] of statsByRootSpan.entries()) {\n          const longestStallTime = Math.max(value.longestStallTime ?? 0, stallTime);\n\n          statsByRootSpan.set(transaction, {\n            ...value,\n            longestStallTime,\n          });\n        }\n      }\n\n      state.lastIntervalMs = now;\n\n      if (state.isTracking && !state.isBackground) {\n        state.timeout = setTimeout(state.iteration, LOOP_TIMEOUT_INTERVAL_MS);\n      }\n    },\n  };\n\n  const setup = (client: Client): void => {\n    client.on('spanStart', _onSpanStart);\n    client.on('spanEnd', _onSpanEnd);\n  };\n\n  const _onSpanStart = (rootSpan: Span): void => {\n    if (!isRootSpan(rootSpan)) {\n      return;\n    }\n\n    if (statsByRootSpan.has(rootSpan)) {\n      debug.error(\n        '[StallTracking] Tried to start stall tracking on a transaction already being tracked. Measurements might be lost.',\n      );\n      return;\n    }\n\n    _startTracking();\n    statsByRootSpan.set(rootSpan, {\n      longestStallTime: 0,\n      atTimestamp: null,\n      atStart: _getCurrentStats(rootSpan),\n    });\n    _flushLeakedTransactions();\n  };\n\n  const _onSpanEnd = (rootSpan: Span): void => {\n    if (!isRootSpan(rootSpan)) {\n      return _onChildSpanEnd(rootSpan);\n    }\n\n    const transactionStats = statsByRootSpan.get(rootSpan);\n\n    if (!transactionStats) {\n      // Transaction has been flushed out somehow, we return null.\n      debug.log('[StallTracking] Stall measurements were not added to transaction due to exceeding the max count.');\n\n      statsByRootSpan.delete(rootSpan);\n      _shouldStopTracking();\n\n      return;\n    }\n\n    // The endTimestamp is always set, but type-wise it's optional\n    // https://github.com/getsentry/sentry-javascript/blob/38bd57b0785c97c413f36f89ff931d927e469078/packages/core/src/tracing/sentrySpan.ts#L170\n    const endTimestamp = spanToJSON(rootSpan).timestamp;\n\n    let statsOnFinish: StallMeasurements | undefined;\n    if (isNearToNow(endTimestamp)) {\n      statsOnFinish = _getCurrentStats(rootSpan);\n    } else {\n      // The idleSpan in JS V8 is always trimmed to the last span's endTimestamp (timestamp).\n      // The unfinished child spans are removed from the root span after the `spanEnd` event.\n\n      const latestChildSpanEnd = getLatestChildSpanEndTimestamp(rootSpan);\n      if (latestChildSpanEnd !== endTimestamp) {\n        debug.log(\n          '[StallTracking] Stall measurements not added due to a custom `endTimestamp` (root end is not equal to the latest child span end).',\n        );\n      }\n\n      if (!transactionStats.atTimestamp) {\n        debug.log(\n          '[StallTracking] Stall measurements not added due to `endTimestamp` not being close to now. And no previous stats from child end were found.',\n        );\n      }\n\n      if (latestChildSpanEnd === endTimestamp && transactionStats.atTimestamp) {\n        statsOnFinish = transactionStats.atTimestamp.stats;\n      }\n    }\n\n    statsByRootSpan.delete(rootSpan);\n    _shouldStopTracking();\n\n    if (!statsOnFinish) {\n      if (typeof endTimestamp !== 'undefined') {\n        debug.log(\n          '[StallTracking] Stall measurements not added due to `endTimestamp` not being close to now.',\n          'endTimestamp',\n          endTimestamp,\n          'now',\n          timestampInSeconds(),\n        );\n      }\n\n      return;\n    }\n\n    setSpanMeasurement(\n      rootSpan,\n      STALL_COUNT,\n      statsOnFinish.stall_count.value - transactionStats.atStart.stall_count.value,\n      transactionStats.atStart.stall_count.unit,\n    );\n\n    setSpanMeasurement(\n      rootSpan,\n      STALL_TOTAL_TIME,\n      statsOnFinish.stall_total_time.value - transactionStats.atStart.stall_total_time.value,\n      transactionStats.atStart.stall_total_time.unit,\n    );\n\n    setSpanMeasurement(\n      rootSpan,\n      STALL_LONGEST_TIME,\n      statsOnFinish.stall_longest_time.value,\n      statsOnFinish.stall_longest_time.unit,\n    );\n  };\n\n  const _onChildSpanEnd = (childSpan: Span): void => {\n    const rootSpan = getRootSpan(childSpan);\n\n    const finalEndTimestamp = spanToJSON(childSpan).timestamp;\n    if (finalEndTimestamp) {\n      _markSpanFinish(rootSpan, finalEndTimestamp);\n    }\n  };\n\n  /**\n   * Logs the finish time of the span for use in `trimEnd: true` transactions.\n   */\n  const _markSpanFinish = (rootSpan: Span, childSpanEndTime: number): void => {\n    const previousStats = statsByRootSpan.get(rootSpan);\n    if (previousStats) {\n      if (Math.abs(timestampInSeconds() - childSpanEndTime) > MARGIN_OF_ERROR_SECONDS) {\n        debug.log(\n          '[StallTracking] Span end not logged due to end timestamp being outside the margin of error from now.',\n        );\n\n        if (previousStats.atTimestamp && previousStats.atTimestamp.timestamp < childSpanEndTime) {\n          // We also need to delete the stat for the last span, as the transaction would be trimmed to this span not the last one.\n          statsByRootSpan.set(rootSpan, {\n            ...previousStats,\n            atTimestamp: null,\n          });\n        }\n      } else {\n        statsByRootSpan.set(rootSpan, {\n          ...previousStats,\n          atTimestamp: {\n            timestamp: childSpanEndTime,\n            stats: _getCurrentStats(rootSpan),\n          },\n        });\n      }\n    }\n  };\n\n  /**\n   * Get the current stats for a transaction at a given time.\n   */\n  const _getCurrentStats = (span: Span): StallMeasurements => {\n    return {\n      stall_count: { value: state.stallCount, unit: 'none' },\n      stall_total_time: { value: state.totalStallTime, unit: 'millisecond' },\n      stall_longest_time: {\n        value: statsByRootSpan.get(span)?.longestStallTime ?? 0,\n        unit: 'millisecond',\n      },\n    };\n  };\n\n  /**\n   * Start tracking stalls\n   */\n  const _startTracking = (): void => {\n    if (!state.isTracking) {\n      state.isTracking = true;\n      state.lastIntervalMs = Math.floor(timestampInSeconds() * 1000);\n\n      state.iteration();\n    }\n  };\n\n  /**\n   * Stops the stall tracking interval and calls reset().\n   */\n  const _stopTracking = (): void => {\n    state.isTracking = false;\n\n    if (state.timeout !== null) {\n      clearTimeout(state.timeout);\n      state.timeout = null;\n    }\n\n    _reset();\n  };\n\n  /**\n   * Will stop tracking if there are no more transactions.\n   */\n  const _shouldStopTracking = (): void => {\n    if (statsByRootSpan.size === 0) {\n      _stopTracking();\n    }\n  };\n\n  /**\n   * Clears all the collected stats\n   */\n  const _reset = (): void => {\n    state.stallCount = 0;\n    state.totalStallTime = 0;\n    state.lastIntervalMs = 0;\n    statsByRootSpan.clear();\n  };\n\n  /**\n   * Deletes leaked transactions (Earliest transactions when we have more than MAX_RUNNING_TRANSACTIONS transactions.)\n   */\n  const _flushLeakedTransactions = (): void => {\n    if (statsByRootSpan.size > MAX_RUNNING_TRANSACTIONS) {\n      let counter = 0;\n      const len = statsByRootSpan.size - MAX_RUNNING_TRANSACTIONS;\n      const transactions = statsByRootSpan.keys();\n      for (const t of transactions) {\n        if (counter >= len) break;\n        counter += 1;\n        statsByRootSpan.delete(t);\n      }\n    }\n  };\n\n  // Avoids throwing any error if using React Native on a environment that doesn't implement AppState.\n  if (AppState?.isAvailable) {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    AppState.addEventListener('change', state.backgroundEventListener);\n  }\n\n  return {\n    name: INTEGRATION_NAME,\n    setup,\n\n    /** For testing only @private */\n    _internalState: state,\n  } as Integration;\n};\n"]}