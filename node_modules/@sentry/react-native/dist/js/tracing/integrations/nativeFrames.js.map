{"version":3,"file":"nativeFrames.js","sourceRoot":"","sources":["../../../../src/js/tracing/integrations/nativeFrames.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Client, Event, Integration, Measurements, MeasurementUnit, Span } from '@sentry/core';\nimport { debug, timestampInSeconds } from '@sentry/core';\nimport type { NativeFramesResponse } from '../../NativeRNSentry';\nimport { AsyncExpiringMap } from '../../utils/AsyncExpiringMap';\nimport { isRootSpan } from '../../utils/span';\nimport { NATIVE } from '../../wrapper';\n\n/**\n * Timeout from the start of a span to fetching the associated native frames.\n */\nconst FETCH_FRAMES_TIMEOUT_MS = 2_000;\n\n/**\n * This is the time end frames data from the native layer will be\n * kept in memory and waiting for the event processing. This ensures that spans\n * which are never processed are not leaking memory.\n */\nconst END_FRAMES_TIMEOUT_MS = 2_000;\n\n/**\n * This is the time start frames data from the native layer will be\n * kept in memory and waiting for span end. This ensures that spans\n * which never end or are not processed are not leaking memory.\n */\nconst START_FRAMES_TIMEOUT_MS = 60_000;\n\n/**\n * A margin of error of 50ms is allowed for the async native bridge call.\n * Anything larger would reduce the accuracy of our frames measurements.\n */\nconst MARGIN_OF_ERROR_SECONDS = 0.05;\n\nconst INTEGRATION_NAME = 'NativeFrames';\n\nexport interface FramesMeasurements extends Measurements {\n  frames_total: { value: number; unit: MeasurementUnit };\n  frames_slow: { value: number; unit: MeasurementUnit };\n  frames_frozen: { value: number; unit: MeasurementUnit };\n}\n\ninterface NativeFramesResponseWithTimestamp {\n  timestamp: number;\n  nativeFrames: NativeFramesResponse;\n}\n\nexport const createNativeFramesIntegrations = (enable: boolean | undefined): Integration | undefined => {\n  if (!enable && NATIVE.enableNative) {\n    // On Android this will free up resource when JS reloaded (native modules stay) and thus JS side of the SDK reinitialized.\n    NATIVE.disableNativeFramesTracking();\n    return undefined;\n  }\n\n  return nativeFramesIntegration();\n};\n\n/**\n * Instrumentation to add native slow/frozen frames measurements onto transactions\n * and frame data (frames.total, frames.slow, frames.frozen) onto all spans.\n */\nexport const nativeFramesIntegration = (): Integration => {\n  /** The native frames at the finish time of the most recent span. */\n  let _lastChildSpanEndFrames: NativeFramesResponseWithTimestamp | null = null;\n  const _spanToNativeFramesAtStartMap: AsyncExpiringMap<string, NativeFramesResponse | null> = new AsyncExpiringMap({\n    ttl: START_FRAMES_TIMEOUT_MS,\n  });\n  const _spanToNativeFramesAtEndMap: AsyncExpiringMap<string, NativeFramesResponseWithTimestamp | null> =\n    new AsyncExpiringMap({ ttl: END_FRAMES_TIMEOUT_MS });\n\n  /**\n   * Hooks into the client start and end span events.\n   */\n  const setup = (client: Client): void => {\n    if (!NATIVE.enableNative) {\n      debug.warn(\n        `[${INTEGRATION_NAME}] This is not available on the Web, Expo Go and other platforms without native modules.`,\n      );\n      return undefined;\n    }\n\n    NATIVE.enableNativeFramesTracking();\n    client.on('spanStart', fetchStartFramesForSpan);\n    client.on('spanEnd', fetchEndFramesForSpan);\n  };\n\n  const fetchStartFramesForSpan = (span: Span): void => {\n    const spanId = span.spanContext().spanId;\n    const spanType = isRootSpan(span) ? 'root' : 'child';\n    debug.log(`[${INTEGRATION_NAME}] Fetching frames for ${spanType} span start (${spanId}).`);\n\n    _spanToNativeFramesAtStartMap.set(\n      spanId,\n      new Promise<NativeFramesResponse | null>(resolve => {\n        fetchNativeFrames()\n          .then(frames => resolve(frames))\n          .then(undefined, error => {\n            debug.log(`[${INTEGRATION_NAME}] Error while fetching native frames.`, error);\n            resolve(null);\n          });\n      }),\n    );\n  };\n\n  /**\n   * Fetches end frames for a span and attaches frame data as span attributes.\n   *\n   * Note: This makes one native bridge call per span end. While this creates O(n) calls\n   * for n spans, it's necessary for accuracy. Frame counts are cumulative and continuously\n   * incrementing, so each span needs the exact frame count at its end time. Caching would\n   * produce incorrect deltas. The native bridge calls are async and non-blocking.\n   */\n  const fetchEndFramesForSpan = async (span: Span): Promise<void> => {\n    const timestamp = timestampInSeconds();\n    const spanId = span.spanContext().spanId;\n    const hasStartFrames = _spanToNativeFramesAtStartMap.has(spanId);\n\n    if (!hasStartFrames) {\n      // We don't have start frames, won't be able to calculate the difference.\n      return;\n    }\n\n    if (isRootSpan(span)) {\n      // Root spans: Store end frames for transaction measurements (backward compatibility)\n      debug.log(`[${INTEGRATION_NAME}] Fetch frames for root span end (${spanId}).`);\n      _spanToNativeFramesAtEndMap.set(\n        spanId,\n        new Promise<NativeFramesResponseWithTimestamp | null>(resolve => {\n          fetchNativeFrames()\n            .then(frames => {\n              resolve({\n                timestamp,\n                nativeFrames: frames,\n              });\n            })\n            .then(undefined, error => {\n              debug.log(`[${INTEGRATION_NAME}] Error while fetching native frames.`, error);\n              resolve(null);\n            });\n        }),\n      );\n    }\n\n    // All spans (root and child): Attach frame data as span attributes\n    try {\n      const startFrames = await _spanToNativeFramesAtStartMap.get(spanId);\n      if (!startFrames) {\n        debug.log(`[${INTEGRATION_NAME}] No start frames found for span ${spanId}, skipping frame data.`);\n        return;\n      }\n\n      // NOTE: For root spans, this is the second call to fetchNativeFrames() for the same span.\n      // The calls are very close together (microseconds apart), so inconsistency is minimal.\n      // Future optimization: reuse the first call's promise to avoid redundant native bridge call.\n      const endFrames = await fetchNativeFrames();\n\n      // Calculate deltas\n      const totalFrames = endFrames.totalFrames - startFrames.totalFrames;\n      const slowFrames = endFrames.slowFrames - startFrames.slowFrames;\n      const frozenFrames = endFrames.frozenFrames - startFrames.frozenFrames;\n\n      // Only attach if we have meaningful data\n      if (totalFrames > 0 || slowFrames > 0 || frozenFrames > 0) {\n        span.setAttribute('frames.total', totalFrames);\n        span.setAttribute('frames.slow', slowFrames);\n        span.setAttribute('frames.frozen', frozenFrames);\n        debug.log(\n          `[${INTEGRATION_NAME}] Attached frame data to span ${spanId}: total=${totalFrames}, slow=${slowFrames}, frozen=${frozenFrames}`,\n        );\n      }\n\n      // Update last child span end frames for root span fallback logic\n      if (!isRootSpan(span)) {\n        _lastChildSpanEndFrames = {\n          timestamp,\n          nativeFrames: endFrames,\n        };\n      }\n    } catch (error) {\n      debug.log(`[${INTEGRATION_NAME}] Error while capturing end frames for span ${spanId}.`, error);\n    }\n  };\n\n  const processEvent = async (event: Event): Promise<Event> => {\n    if (\n      event.type !== 'transaction' ||\n      !event.transaction ||\n      !event.contexts ||\n      !event.contexts.trace ||\n      !event.timestamp ||\n      !event.contexts.trace.span_id\n    ) {\n      return event;\n    }\n\n    const traceOp = event.contexts.trace.op;\n    const spanId = event.contexts.trace.span_id;\n    const startFrames = await _spanToNativeFramesAtStartMap.pop(spanId);\n    if (!startFrames) {\n      debug.warn(\n        `[${INTEGRATION_NAME}] Start frames of transaction ${event.transaction} (eventId, ${event.event_id}) are missing, but the transaction already ended.`,\n      );\n      return event;\n    }\n\n    const endFrames = await _spanToNativeFramesAtEndMap.pop(spanId);\n    let finalEndFrames: NativeFramesResponse | undefined;\n\n    if (endFrames && isClose(endFrames.timestamp, event.timestamp)) {\n      // Must be in the margin of error of the actual transaction finish time (finalEndTimestamp)\n      debug.log(`[${INTEGRATION_NAME}] Using frames from root span end (spanId, ${spanId}).`);\n      finalEndFrames = endFrames.nativeFrames;\n    } else if (_lastChildSpanEndFrames && isClose(_lastChildSpanEndFrames.timestamp, event.timestamp)) {\n      // Fallback to the last span finish if it is within the margin of error of the actual finish timestamp.\n      // This should be the case for trimEnd.\n      debug.log(`[${INTEGRATION_NAME}] Using native frames from last child span end (spanId, ${spanId}).`);\n      finalEndFrames = _lastChildSpanEndFrames.nativeFrames;\n    } else {\n      debug.warn(\n        `[${INTEGRATION_NAME}] Frames were collected within larger than margin of error delay for spanId (${spanId}). Dropping the inaccurate values.`,\n      );\n      return event;\n    }\n\n    const measurements = {\n      frames_total: {\n        value: finalEndFrames.totalFrames - startFrames.totalFrames,\n        unit: 'none',\n      },\n      frames_frozen: {\n        value: finalEndFrames.frozenFrames - startFrames.frozenFrames,\n        unit: 'none',\n      },\n      frames_slow: {\n        value: finalEndFrames.slowFrames - startFrames.slowFrames,\n        unit: 'none',\n      },\n    };\n\n    if (\n      measurements.frames_frozen.value <= 0 &&\n      measurements.frames_slow.value <= 0 &&\n      measurements.frames_total.value <= 0\n    ) {\n      debug.warn(\n        `[${INTEGRATION_NAME}] Detected zero slow or frozen frames. Not adding measurements to spanId (${spanId}).`,\n      );\n      return event;\n    }\n\n    debug.log(\n      `[${INTEGRATION_NAME}] Adding measurements to ${traceOp} transaction ${event.transaction}: ${JSON.stringify(\n        measurements,\n        undefined,\n        2,\n      )}`,\n    );\n    event.measurements = {\n      ...(event.measurements ?? {}),\n      ...measurements,\n    };\n    return event;\n  };\n\n  return {\n    name: INTEGRATION_NAME,\n    setup,\n    processEvent,\n  };\n};\n\nfunction fetchNativeFrames(): Promise<NativeFramesResponse> {\n  return new Promise<NativeFramesResponse>((resolve, reject) => {\n    let settled = false;\n\n    const timeoutId = setTimeout(() => {\n      if (!settled) {\n        settled = true;\n        reject('Fetching native frames took too long. Dropping frames.');\n      }\n    }, FETCH_FRAMES_TIMEOUT_MS);\n\n    NATIVE.fetchNativeFrames()\n      .then(value => {\n        if (settled) {\n          return;\n        }\n        clearTimeout(timeoutId);\n        settled = true;\n\n        if (!value) {\n          reject('Native frames response is null.');\n          return;\n        }\n        resolve(value);\n      })\n      .then(undefined, error => {\n        if (settled) {\n          return;\n        }\n        clearTimeout(timeoutId);\n        settled = true;\n        reject(error);\n      });\n  });\n}\n\nfunction isClose(t1: number, t2: number): boolean {\n  return Math.abs(t1 - t2) < MARGIN_OF_ERROR_SECONDS;\n}\n"]}