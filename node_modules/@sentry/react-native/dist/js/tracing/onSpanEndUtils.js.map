{"version":3,"file":"onSpanEndUtils.js","sourceRoot":"","sources":["../../../src/js/tracing/onSpanEndUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Client, Span } from '@sentry/core';\nimport { debug, getSpanDescendants, SPAN_STATUS_ERROR, spanToJSON } from '@sentry/core';\nimport type { AppStateStatus } from 'react-native';\nimport { AppState } from 'react-native';\nimport { isRootSpan, isSentrySpan } from '../utils/span';\n\n/**\n * Hooks on span end event to execute a callback when the span ends.\n */\nexport function onThisSpanEnd(client: Client, span: Span, callback: (span: Span) => void): void {\n  client.on('spanEnd', (endedSpan: Span) => {\n    if (span !== endedSpan) {\n      return;\n    }\n    callback(endedSpan);\n  });\n}\n\nexport const adjustTransactionDuration = (client: Client, span: Span, maxDurationMs: number): void => {\n  if (!isRootSpan(span)) {\n    debug.warn('Not sampling empty back spans only works for Sentry Transactions (Root Spans).');\n    return;\n  }\n\n  client.on('spanEnd', (endedSpan: Span) => {\n    if (endedSpan !== span) {\n      return;\n    }\n\n    const endTimestamp = spanToJSON(span).timestamp;\n    const startTimestamp = spanToJSON(span).start_timestamp;\n    if (!endTimestamp || !startTimestamp) {\n      return;\n    }\n\n    const diff = endTimestamp - startTimestamp;\n    const isOutdatedTransaction = endTimestamp && (diff > maxDurationMs || diff < 0);\n    if (isOutdatedTransaction) {\n      span.setStatus({ code: SPAN_STATUS_ERROR, message: 'deadline_exceeded' });\n      // TODO: check where was used, might be possible to delete\n      span.setAttribute('maxTransactionDurationExceeded', 'true');\n    }\n  });\n};\n\n/**\n * Helper function to filter out auto-instrumentation child spans.\n */\nfunction getMeaningfulChildSpans(span: Span): Span[] {\n  const children = getSpanDescendants(span);\n  return children.filter(\n    child =>\n      child.spanContext().spanId !== span.spanContext().spanId &&\n      spanToJSON(child).op !== 'ui.load.initial_display' &&\n      spanToJSON(child).op !== 'navigation.processing',\n  );\n}\n\n/**\n * Generic helper to discard empty navigation spans based on a condition.\n */\nfunction discardEmptyNavigationSpan(\n  client: Client | undefined,\n  span: Span | undefined,\n  shouldDiscardFn: (span: Span) => boolean,\n  onDiscardFn: (span: Span) => void,\n): void {\n  if (!client) {\n    debug.warn('Could not hook on spanEnd event because client is not defined.');\n    return;\n  }\n\n  if (!span) {\n    debug.warn('Could not hook on spanEnd event because span is not defined.');\n    return;\n  }\n\n  if (!isRootSpan(span) || !isSentrySpan(span)) {\n    debug.warn('Not sampling empty navigation spans only works for Sentry Transactions (Root Spans).');\n    return;\n  }\n\n  client.on('spanEnd', (endedSpan: Span) => {\n    if (endedSpan !== span) {\n      return;\n    }\n\n    if (!shouldDiscardFn(span)) {\n      return;\n    }\n\n    const meaningfulChildren = getMeaningfulChildSpans(span);\n    if (meaningfulChildren.length <= 0) {\n      onDiscardFn(span);\n      span['_sampled'] = false;\n    }\n  });\n}\n\nexport const ignoreEmptyBackNavigation = (client: Client | undefined, span: Span | undefined): void => {\n  discardEmptyNavigationSpan(\n    client,\n    span,\n    // Only discard if route has been seen before\n    span => spanToJSON(span).data?.['route.has_been_seen'] === true,\n    // Log message when discarding\n    () => {\n      debug.log(\n        'Not sampling transaction as route has been seen before. Pass ignoreEmptyBackNavigationTransactions = false to disable this feature.',\n      );\n    },\n  );\n};\n\n/**\n * Discards empty \"Route Change\" transactions that never received route information.\n * This happens when navigation library emits a route change event but getCurrentRoute() returns undefined.\n * Such transactions don't contain any useful information and should not be sent to Sentry.\n *\n * This function must be called with a reference tracker function that can check if the span\n * was cleared from the integration's tracking (indicating it went through the state listener).\n */\nexport const ignoreEmptyRouteChangeTransactions = (\n  client: Client | undefined,\n  span: Span | undefined,\n  defaultNavigationSpanName: string,\n  isSpanStillTracked: () => boolean,\n): void => {\n  discardEmptyNavigationSpan(\n    client,\n    span,\n    // Only discard if:\n    // 1. Still has default name\n    // 2. No route information was set\n    // 3. Still being tracked (state listener never called)\n    span => {\n      const spanJSON = spanToJSON(span);\n      return (\n        spanJSON.description === defaultNavigationSpanName && !spanJSON.data?.['route.name'] && isSpanStillTracked()\n      );\n    },\n    // Log and record dropped event\n    _span => {\n      debug.log(`Discarding empty \"${defaultNavigationSpanName}\" transaction that never received route information.`);\n      client?.recordDroppedEvent('sample_rate', 'transaction');\n    },\n  );\n};\n\n/**\n * Idle Transaction callback to only sample transactions with child spans.\n * To avoid side effects of other callbacks this should be hooked as the last callback.\n */\nexport const onlySampleIfChildSpans = (client: Client, span: Span): void => {\n  if (!isRootSpan(span) || !isSentrySpan(span)) {\n    debug.warn('Not sampling childless spans only works for Sentry Transactions (Root Spans).');\n    return;\n  }\n\n  client.on('spanEnd', (endedSpan: Span) => {\n    if (endedSpan !== span) {\n      return;\n    }\n\n    const children = getSpanDescendants(span);\n\n    if (children.length <= 1) {\n      // Span always has at lest one child, itself\n      debug.log(`Not sampling as ${spanToJSON(span).op} transaction has no child spans.`);\n      span['_sampled'] = false;\n    }\n  });\n};\n\n/**\n * Hooks on AppState change to cancel the span if the app goes background.\n */\nexport const cancelInBackground = (client: Client, span: Span): void => {\n  const subscription = AppState.addEventListener('change', (newState: AppStateStatus) => {\n    if (newState === 'background') {\n      debug.log(`Setting ${spanToJSON(span).op} transaction to cancelled because the app is in the background.`);\n      span.setStatus({ code: SPAN_STATUS_ERROR, message: 'cancelled' });\n      span.end();\n    }\n  });\n\n  subscription &&\n    client.on('spanEnd', (endedSpan: Span) => {\n      if (endedSpan === span) {\n        debug.log(`Removing AppState listener for ${spanToJSON(span).op} transaction.`);\n        subscription?.remove?.();\n      }\n    });\n};\n"]}